1. 学习使用关联容器map的基本用法：初始化、插入新值、，初步了解STL中map的底层实现机制; 
map中元素属于pair类型，为pair<const key_type, mapped_type>，该pair类型整体被定义为value_type
（在学习顺序容器的时候其实已经有讲到vale_type表示的是容器的元素类型，比如vector<int>，那么这个容器的value_type为int）
所以mapped_type才是一般常提到的字典值的数据类型；访问map元素的key和value时，使用pair类型的first和second数据成员名
2. 有序容器的begin(), end() 与 front()，back()的区别，
begin()/end()返回类型为container_type<value_type>::iterator/const_iterator，迭代器解引用才得到对应元素的引用类型；
front()/back()返回类型为container_type<value_type>::reference/const_reference
3. 迭代器再理解：http://c.biancheng.net/view/338.html
4. 代码简洁：函数返回为容器时，一般可以使用花括号作为返回值，返回时自动调用对应容器的构造函数（构造器）

C++中map，有三种类型：

|映射 |底层实现 | 是否有序 |数值是否可以重复 | 能否更改数值|查询效率 |增删效率|
|---|---| --- |---| --- | --- | ---|
|std::map |红黑树 |key有序 |key不可重复 |key不可修改 | O(log n)|O(log n) |
|std::multimap | 红黑树|key有序 | key可重复 | key不可修改|O(log n) |O(log n) |
|std::unordered_map |哈希表 | key无序 |key不可重复 |key不可修改 |O(1) | O(1)|

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。

同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。

```
class Solution {
public:
  vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> searched;
    
    for (int i = 0; i < nums.size(); ++i) {
      unordered_map<int, int>::iterator iter = searched.find(target - nums[i]);
      if (iter != searched.end()) {
        return {iter->second, i};
      }
      searched.insert(pair<int, int>{nums[i], i});
    }
    return vector<int>(2);
  }
};
```
